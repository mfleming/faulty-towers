# Desige Doc for Faulty Towers

## Introduction

Fault Injection, or Software Fault Injection (SFI) is the process of modifying running software by
intentionally causing faults. The idea is to do this in a controlled way during testing so that we
can have confidence our systems will continue to perform in the face of real-world faults.

Availability of services is critically important for businesses that store user data. Fault
injection can improve availability at every point of the development process, from initial
development to deployment and operation.

Faulty Towers is a Java agent that will inject faults into Apache Cassandra both during unit tests
and also longer running tests. Faults are injected at the application level and other kinds of fault
injection or chaos engineering are left to other tools, e.g. https://chaos-mesh.org/[chaos-mesh]
creates faults at the infrastructure level by killing kubernetes pods. 

## Design

Faulty Towers runs as a Java agent which attaches to a JVM either running JUnit unit tests or some
other long-running workload. Faults are injected based on either test code coverage data (in the
case of JUnit) or profile data.

To make sure that we trigger any faults that we inject, Faulty Towers uses call graph data to find
which code paths are traversed during a workload and only inserts faults into those paths.

### Offline Fault Injection

Short-lived workloads, such as JUnit tests require code coverage data such as the data generated by
https://github.com/jacoco/jacoco[JaCoCo]. This means Faulty Towers needs to be run twice -- once to
collect coverage data and a second time to use the coverage data to inject faults that are likely to
be executed.

The output of the first run is a coverage file that is used as input to the second run.

### Online Fault Injection

For long-running tests such as performance benchmarks or stress workloads, Faulty Towers uses a
profiler to collect call graph data at runtime and inserts faults without needing to restart the
workload.

A potential drawback of this approach is that, if the workload characteristics change, the faults
injected by Faulty Towers might not be triggered.

### Random Fault Selection

We should use randomisation so that we're not always testing the same code paths and fault tolerance
but with records but we also need an audit log of what happened so we can diagnose faults and
reproduce problems.

### Faults To Inject

#### Exceptions

https://github.com/mrwilson/byte-monkey[byte-monkey] is perfectly suitable for throwing checked
exceptions, see the 'short-circuit' option, but has no support for throwing unchecked exceptions.
Apache Cassandra makes heavy use of unchecked exceptions. This is a fertile ground for bugs because
by definition the compiler will not check that those exceptions are caught and handled correctly.

However, one thing to check is that it can throw exceptions outside of try/catch blocks, e.g. to
make sure that things are cleaned up properly by intermediate method in the call stack.

It'd be better if we could throw unchecked exceptions, i.e. RuntimeException because by definition
the compiler does not require that they're handled correctly.

## Components to test

### Storage

 - Corrupt SSTables
 - Corrupt metadata
 - Exhaust file descriptors

### Network

 - Latency increase
 - Packet transmit errors
 - Bandwidth constraints
 - Malformed packets

## Tools

### byte-monkey

### CHAOSMACHINE

https://blog.gluckzhang.com/archives/158/

## References

- Assessing Dependability with Software Fault Injection: A Survey
